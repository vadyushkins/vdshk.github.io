<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Matrix | vdshk blog</title><link>https://vdshk.me/tag/matrix/</link><atom:link href="https://vdshk.me/tag/matrix/index.xml" rel="self" type="application/rss+xml"/><description>Matrix</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ru</language><copyright>© 2021 Vadim Abzalov</copyright><lastBuildDate>Tue, 09 Nov 2021 12:45:16 +0300</lastBuildDate><image><url>https://vdshk.me/media/icon_hua908ffaee85184b139d79f55f9be504d_127086_512x512_fill_lanczos_center_3.png</url><title>Matrix</title><link>https://vdshk.me/tag/matrix/</link></image><item><title>LeetCode 807</title><link>https://vdshk.me/post/leetcode-807/</link><pubDate>Tue, 09 Nov 2021 12:45:16 +0300</pubDate><guid>https://vdshk.me/post/leetcode-807/</guid><description>&lt;blockquote>
&lt;p>🙏 Спасибо LeetCode за замечательную задачу &lt;a href="https://leetcode.com/problems/max-increase-to-keep-city-skyline/" target="_blank" rel="noopener">&amp;ldquo;807. Max Increase to Keep City Skyline&amp;rdquo;&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;details class="toc-inpage d-print-none " open>
&lt;summary class="font-weight-bold">Содержание&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#задача">Задача&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#ограничения">Ограничения&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#примеры">Примеры&lt;/a>&lt;/li>
&lt;li>&lt;a href="#решение">Решение&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Имеется город, состоящий из $n \times n$ блоков, где каждый блок содержит ровно одно
здание в форме вертикальной квадратной призмы.
Дана &lt;strong>заиндексированная с 0&lt;/strong> матрица целых чисел &lt;code>grid&lt;/code>,
где &lt;code>grid[i][j]&lt;/code> - представляет собой &lt;strong>высоту&lt;/strong> здания, находящегося
в блоке на &lt;code>i&lt;/code>-ой строке в &lt;code>j&lt;/code>-ом столбце города.&lt;/p>
&lt;p>&lt;strong>Горизонт города&lt;/strong> - это внешний контур города, образованный всеми зданиями,
есди смотреть на город издалека.
&lt;strong>Горизонт города&lt;/strong> с каждой стороны света может выглядеть по-разному.&lt;/p>
&lt;p>Разрешается увеличивать высоту любого здания на любую величину, но горизонт города
не должен меняться с любой стороны света.&lt;/p>
&lt;p>От вас требуется вычислить максимальную сумму, на которую может быть увеличена высота
зданий без изменения горизонта города с любой стороны света.&lt;/p>
&lt;h3 id="ограничения">Ограничения&lt;/h3>
&lt;ul>
&lt;li>&lt;code>n == grid.length&lt;/code>&lt;/li>
&lt;li>$\forall i \in \{0, \dots, n - 1\}: $ &lt;code>n == grid[i].length&lt;/code>&lt;/li>
&lt;li>$2 \leq n \leq 50$&lt;/li>
&lt;li>$0 \leq grid[i][j] \leq 100$&lt;/li>
&lt;/ul>
&lt;h2 id="примеры">Примеры&lt;/h2>
&lt;pre>&lt;code class="language-text">Input: grid = [ [3, 0, 8, 4],
[2, 4, 5, 7],
[9, 2, 6, 3],
[0, 3, 1, 0] ]
Output: 35
`grid` города после максимального возможного увеличения высот всех зданий
new_grid = [ [8, 4, 8, 7],
[7, 4, 7, 7],
[9, 4, 8, 7],
[3, 3, 3, 3] ]
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-text">Input: grid = [[0,0,0],[0,0,0],[0,0,0]]
Output: 0
Нельзя увеличить ни одно здание, так как тогда горизонт города изменится.
&lt;/code>&lt;/pre>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;ul>
&lt;li>Пусть новые высоты зданий это $grid'$&lt;/li>
&lt;li>Так как мы хотим максимизировать $\underset{i, j}{\sum}\{grid'[i][j] - grid[i][j]\}$,
то нам необходимо максимизировать $grid'[i][j]$ для всех $i, j$&lt;/li>
&lt;li>Заметим, что
&lt;ul>
&lt;li>$\forall i, j: grid'[i][j] \leq \underset{0 \leq k &amp;lt; n}{\max}\{grid[i][k]\}$&lt;/li>
&lt;li>$\forall i, j: grid'[i][j] \leq \underset{0 \leq k &amp;lt; n}{\max}\{grid[k][j]\}$&lt;/li>
&lt;li>так как если здание станет выше, чем самое высокое здание в его строке или столбце,
то горизонт города изменится&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Значит $$\forall i, j: grid'[i][j] \leq \min(\underset{0 \leq k &amp;lt; n}{\max}\{grid[i][k]\}, \underset{0 \leq k &amp;lt; n}{\max}\{grid[k][j]\})$$&lt;/li>
&lt;li>Отсюда уже очевидно, что $$grid'[i][j] = \min(\underset{0 \leq k &amp;lt; n}{\max}\{grid[i][k]\}, \underset{0 \leq k &amp;lt; n}{\max}\{grid[k][j]\})$$&lt;/li>
&lt;li>А ответ это $$\underset{i, j}{\sum}\{\min(\underset{0 \leq k &amp;lt; n}{\max}\{grid[i][k]\}, \underset{0 \leq k &amp;lt; n}{\max}\{grid[k][j]\}) - grid[i][j]\}$$&lt;/li>
&lt;/ul>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>Python&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-python">class Solution:
def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&amp;gt; int:
row_max = list(map(max, grid))
col_max = list(map(max, zip(*grid)))
return sum(
min(row_max[i], col_max[j]) - val
for i, row in enumerate(grid)
for j, val in enumerate(row)
)
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>C++&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
#define len(a) (int)a.size()
using namespace std;
typedef string str;
class Solution {
public:
int maxIncreaseKeepingSkyline(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
int n = len(grid);
vector&amp;lt;int&amp;gt; row_max(n, -1);
vector&amp;lt;int&amp;gt; col_max(n, -1);
for (int i = 0; i &amp;lt; n; ++i) {
for (int j = 0; j &amp;lt; n; ++j) {
row_max[i] = max(row_max[i], grid[i][j]);
col_max[j] = max(col_max[j], grid[i][j]);
}
}
int res = 0;
for (int i = 0; i &amp;lt; n; ++i) {
for (int j = 0; j &amp;lt; n; ++j) {
res += min(row_max[i], col_max[j]) - grid[i][j];
}
}
return res;
}
};
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>JavaScript&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-javascript">/**
* @param {number[][]} grid
* @return {number}
*/
var maxIncreaseKeepingSkyline = function(grid) {
const n = grid.length;
const row_max = Array(n).fill(-1);
const col_max = Array(n).fill(-1);
for (let i = 0; i &amp;lt; n; ++i) {
for (let j = 0; j &amp;lt; n; ++j) {
row_max[i] = Math.max(row_max[i], grid[i][j]);
col_max[j] = Math.max(col_max[j], grid[i][j]);
}
}
let res = 0;
for (let i = 0; i &amp;lt; n; ++i) {
for (let j = 0; j &amp;lt; n; ++j) {
res += Math.min(row_max[i], col_max[j]) - grid[i][j];
}
}
return res;
};
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details></description></item></channel></rss>